Python FAQ : 参数传递
====

[原文出处]()

**我怎样才能传引用？Python中是传值还是传引用？**

这个问题最常被从C++社区迁移过来的人问起，因为他们惯于记住这两种传递的泾渭分明和一串微妙的不同之处。

所以，Python是传值还是传引用的？

简单的答案：对象大致上是不加复制地传引用。如果你在一个函数中修改了一个对象，它将在调用时改变。
但是！你不能赋值给一个参数名并魔法般改变它在调用时的值。

详细的答案：都是，或者都不是。嗯……这需要一些篇幅来解释。

引用和值
----

在C和C++，变量声明就是储存声明。考虑下面无足轻重的语句：

    int x;

这里不是真的创建了名为x的东西。它只是确保，在运行时将会分配出一块足够储存整型的空间，
而且每当代码中用到x时，它将会到那块空间中查找值。
至于那块空间是在RAM里还是在交换区里还是躺在床上睡大觉甚至在月球上某个地方，你不需要在乎。
如果你使用了寄存器，它甚至压根不在系统储存空间中。
所有的x的储存位置是你跟你的编译器的私下约定——
承诺每一次你提到x，你都是谈及同样的地方，就像其他任何时候一样。

到了函数调用的时候……

    void do_the_needful(some_bigass_struct foo){
        /* ... */
    }

`some_bigass_struct foo`依然是一个变量声明。
在运行时，你将有一块等同于结构体大小的空间，而且在函数中每次提到`foo`，你会确保谈及同样的空间。

所以，函数的任何参数都是复制的。当函数调用时，`foo`包括了作为参数逐字节复制进来的结构体。
这就是传值——函数接受等价的值，但参数有着不一样的本体(或者储存位置)。

显然这不适合notrivial类型(译注：比如类类型)。
你浪费了太多时间来复制整个结构，而且你的函数居然不能修改调用栈任何东西，因为你拥有的仅仅是一个副本。

C中的修复方法是传指针。从技术上来说，它还是传值，不过这里的“值”是内存地址(仅仅几个比特)。
尽管指针本体不一样，它依然指向同样的结构体，所以若你乐意，现在可以“弄脏”这个结构体了。

再来看看C++。C++觉得指针是令人费解的，
因为大学费力地在CS102课堂上向连编译器都不甚了解的学生们灌输指针的知识，而他们当然搞不懂。
好吧，让我们不用指针解决这个问题。

C++的解决之道是引入references(引用)

    void do_the_needful(some_bigass_struct &foo){
        // whoa, inline comment
    }

现在你可以毫不犹豫地调用`do_the_needful(bar)`。
看上去整个结构体都传递进去了，但`&`使得`foo`成为`bar`的一个别名。
换句话说，`foo`不再是运行时的一块储存空间，而是调用栈中的一块空间的另一种说法。
因为`foo`是`bar`，你甚至可以赋值给`foo`并覆盖`bar`——在C中做这样的事，你不得不使用双重指针来避免复制。

这就是传引用：同样的储存空间由两个不同的变量共享，一个在C中不可能的技巧。

回到Python
----

经过这些(希望比较清晰的)定义后，让我们再看看Python的做法。

    def do_the_needful(foo):
        pass

    obj = SomeBigassClass()
    do_the_needful(obj)

`foo`是传值还是传引用？

简单的回答是，都不是。但是完整的答案是这个问题对于Python是个伪命题！
变量名并不像C/C++中一样对应着预先分配的储存空间。Python变量名仅仅是：变量名。

比较：

* 在C中，`int x = 3;`声明了一块叫`x`的储存空间，并写入`3`。
* 在Python中，`x = 3`创建值`3`并以`x`作为它的名字。所有的值都是对象；它们可以拥有许多绰号或者默默无名。

比个喻：C变量就像写入值的盒子。Python名字是你贴在值上的标签。
这里有个酷的[示例](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables)。

很像C的一点，参数传递就像是赋值。函数中`foo`参数就像`foo = obj`那样被赋值；效果是一样的。

这不是传值，因为没有产生复制，而且函数拥有和调用者同样的对象。
(Python从不隐式复制任何东西) 它是传引用么？至少目前看来就像C++的引用。

    def increment(n):
        n = n + 1

    i = 1
    print i
    increment(i)
    print i

不，仅仅是输出两次1!在函数中，赋值给`n`不会影响`n`所引用的值；它只是让`n`这个名字引用另外别的东西。
所以`n`将会是`2`。然后函数结束了，`n`随风而逝。结果`i`没有改变因为你没有对`i`做任何事情。


