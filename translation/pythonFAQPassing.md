Python FAQ : 参数传递
====

[原文出处](http://me.veekun.com/blog/2012/05/23/python-faq-passing/)

**我怎样才能传引用？Python中是传值还是传引用？**

这个问题最常被从C++社区迁移过来的人问起，因为他们惯于记住这两种传递的泾渭分明和一串微妙的不同之处。

所以，Python是传值还是传引用的？

简单的答案：对象大致上是不加复制地传引用。如果你在一个函数中修改了一个对象，它将在调用时改变。
但是！你不能赋值给一个参数名并魔法般改变它在调用时的值。

详细的答案：都是，或者都不是。嗯……这需要一些篇幅来解释。

引用和值
----

在C和C++，变量声明就是储存声明。考虑下面无足轻重的语句：

    int x;

这里不是真的创建了名为x的东西。它只是确保，在运行时将会分配出一块足够储存整型的空间，
而且每当代码中用到x时，它将会到那块空间中查找值。
至于那块空间是在RAM里还是在交换区里还是躺在床上睡大觉甚至在月球上某个地方，你不需要在乎。
如果你使用了寄存器，它甚至压根不在系统储存空间中。
所有的x的储存位置是你跟你的编译器的私下约定——
承诺每一次你提到x，你都是谈及同样的地方，就像其他任何时候一样。

到了函数调用的时候……

    void do_the_needful(some_bigass_struct foo){
        /* ... */
    }

`some_bigass_struct foo`依然是一个变量声明。
在运行时，你将有一块等同于结构体大小的空间，而且在函数中每次提到`foo`，你会确保谈及同样的空间。

所以，函数的任何参数都是复制的。当函数调用时，`foo`包括了作为参数逐字节复制进来的结构体。
这就是传值——函数接受等价的值，但参数有着不一样的本体(或者储存位置)。

显然这不适合notrivial类型(译注：比如类类型)。
你浪费了太多时间来复制整个结构，而且你的函数居然不能修改调用栈任何东西，因为你拥有的仅仅是一个副本。

C中的修复方法是传指针。从技术上来说，它还是传值，不过这里的“值”是内存地址(仅仅几个比特)。
尽管指针本体不一样，它依然指向同样的结构体，所以若你乐意，现在可以“弄脏”这个结构体了。

再来看看C++。C++觉得指针是令人费解的，
因为大学费力地在CS102课堂上向连编译器都不甚了解的学生们灌输指针的知识，而他们当然搞不懂。
好吧，让我们不用指针解决这个问题。

C++的解决之道是引入references(引用)

    void do_the_needful(some_bigass_struct &foo){
        // whoa, inline comment
    }

现在你可以毫不犹豫地调用`do_the_needful(bar)`。
看上去整个结构体都传递进去了，但`&`使得`foo`成为`bar`的一个别名。
换句话说，`foo`不再是运行时的一块储存空间，而是调用栈中的一块空间的另一种说法。
因为`foo`是`bar`，你甚至可以赋值给`foo`并覆盖`bar`——在C中做这样的事，你不得不使用双重指针来避免复制。

这就是传引用：同样的储存空间由两个不同的变量共享，一个在C中不可能的技巧。

回到Python
----

经过这些(希望比较清晰的)定义后，让我们再看看Python的做法。

    def do_the_needful(foo):
        pass

    obj = SomeBigassClass()
    do_the_needful(obj)

`foo`是传值还是传引用？

简单的回答是，都不是。但是完整的答案是这个问题对于Python是个伪命题！
变量名并不像C/C++中一样对应着预先分配的储存空间。Python变量名仅仅是：变量名。

比较：

* 在C中，`int x = 3;`声明了一块叫`x`的储存空间，并写入`3`。
* 在Python中，`x = 3`创建值`3`并以`x`作为它的名字。所有的值都是对象；它们可以拥有许多绰号或者默默无名。

比个喻：C变量就像写入值的盒子。Python名字是你贴在值上的标签。
这里有个酷的[示例](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables)。

很像C的一点，参数传递就像是赋值。函数中`foo`参数就像`foo = obj`那样被赋值；效果是一样的。

这不是传值，因为没有产生复制，而且函数拥有和调用者同样的对象。
(Python从不隐式复制任何东西) 它是传引用么？至少目前看来就像C++的引用。

    def increment(n):
        n = n + 1

    i = 1
    print i
    increment(i)
    print i

不，仅仅是输出两次1!在函数中，赋值给`n`不会影响`n`所引用的值；它只是让`n`这个名字引用另外别的东西。
所以`n`将会是`2`。然后函数结束了，`n`随风而逝。结果`i`没有改变因为你没有对`i`做任何事情。

这跟改变一个现有的值不一样：

    def lengthen(n):
        n.append(2)

    i = [1]
    print i # [1]
    lengthen(i)
    print i # [1,2]

这一次，`n`不再被重新赋值；相反，方法调用直接修改了`n`的值。
还是熟悉的列表，`n`和`i`依然引用它，但是列表的内容改变了。

懂了没？
还有另外一个小技巧：操作符重载在这里起到不可思议的作用。
举个例子，你可以用**+=**重写这两函数。在`increment`中，`i`不会改变，但在`lengthen`中，它变了！
这是因为ints(还有strs,tuples,以及其他类型)是不可变的，所以它们通过创建一个新对象并赋值给原对象来实现+=。
但是lists是可变的，所以作为简写法，+=表现得如同`.extend()`并原地(in-place)修改列表。
这种古怪之处与传递无关，仅仅是因为对+=不同的重载。

总之，嗯，这当然也不是传引用。

如果有区别的话，Python走的是第三条道路：pass-by-object。

替代的做法
----

等等，当你写下`increment`时，你想做什么？

* **返回原料**

    在C/C++中指针/引用参数的大多数用法是获取一些状态值，并且函数的结果通过修改特定的输入变量表现出来。

    但这不是C，所以为什么我们要这样做呢？你可以仅仅返回多个值。

        def foo():
            return True,"abc"

        status,value = foo()

    或者，在错误的时候抛出异常。当调用者忘记检查状态码时，也不会大吃一惊。

* **使用方法**

    如果你*真的*想修改调用者的值，你就可以使用一个对象来储存关联的值，并把函数变为方法。
    方法可以跟所需要的调用者的属性打交道，并把修改后的状态封装起来。

        class Increment(object):
            def __init__(self,count):
                self.count = count

            def increment(self):
                self.count += 1

        i = Increment(1)
        print i.count # 1
        i.increment()
        print i.count # 2

* **使用可变对象**

    最后一招，你可以把值包装在list(或dict,object,etc.)，传递到函数去，让函数修改它的值，并在输出端提取新的值。

    我开玩笑而已，千万不要这么做。

寻根究底
----

如果你想要知道的话！在CPython中，每一个Python的值实际上是`PyObject*`。所以参数传递，赋值还有别的表现得跟C语言中的是差不多的，
如果你写的C中所有的东西都是指针(并且不用双重指针来表演障眼法)。

    void increment(int *n){
        int newval = *n + 1;
        n = &newval;
    }

    int i = 1;
    increment(&i);

这跟上面的Python函数等价的。(请忽略接下来的segfault)
赋值给`n`不会有什么变化，因为只有指针指向的值是共享的。
但是如果值类似于列表是可变的，你可以在原地改变它。

这就是为什么两个答案都是对的：你可以说Python是传值，当值是指针……你也可以说Python是传引用，当引用是副本。
你也可以说它是"pass-by-pointer"。不过这就是钻牛角尖了。

结论
----

* Python函数不会替换调用参数所引用的对象。
* 对一个参数名重新赋值不会起任何作用。
* Python函数可以修改参数，如果这个参数是可变的。
* 在Python中没有什么是被隐式复制的。
* 停止用C++的思维打量Python，你会感觉更良好。

拓展阅读
----

* Python官方文档没有透彻地诠释传递的语法。我能找到的最好的说明在[这里](http://docs.python.org/reference/expressions.html#calls )
* 这个[示例](http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html#other-languages-have-variables )真的酷毙了。
* Pass-by-object有时也叫pass-by-sharing.from [维基百科](http://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_sharing)

