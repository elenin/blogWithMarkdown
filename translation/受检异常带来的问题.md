受检异常带来的麻烦
====

**与Anders Hejlsberg的一次会谈，第二部分**

采访人 Bill Venners , Bruce Eckel

2003年8月18日

##摘要
----

**Anders Hejlsberg,C#的首席架构师，跟Bruce Eckel和Bill Venners讨论了由受检异常(checked exception)带来的版本(versionability)和拓展性(scalability)的问题。**

(以下略去人物介绍和访谈背景)

##访谈内容
----

(跳过第一部分)

Bruce Eckel: C# 没有受检异常。
你为何决定不在C#中加入受检异常呢？ 

Anders Hejlsberg: 在我看来，受检异常有两个大问题：拓展性和版本。
我听说你也写过一些关于受检异常的东西，并且倾向于同意我们的观点。

Bruce Eckel: 我曾认为受检异常是好的。

Anders Hejlsberg: 的确。坦白来说，受检异常看上去是个不错的点子。
我完全同意受检异常是个好特性。
只是某些实现存在问题罢了。
比如它在Java中的实现，我认为只是拿一堆问题来取代另一堆问题。
到了最后，我还是搞不懂这一切是否变得更简单了。也许变得更复杂呢。

Bruce Eckel: 在C#的设计团队中，普遍存在对受检异常的反对吗？

Anders Hejlsberg: 不，我认为我们的设计团队对此是一致的。

C#基本上对受检异常不置可否。
一旦有更好的解决方法———相信我，我们依然在考虑——我们会回头添加一些特性。
我深信，如果你不知道什么是正确的，或该如何改进，就应该保持沉默和中立，而不是草率推出一个框架。

如果你让菜鸟程序员写一个日历控件，他们多半会这么想：“
我要写一个世上最好的日历控件！
它将会通过多态展示不同的类型。
它将有显示器(displayers)和mungers，还将有这个、那个……
他们需要两个月才能发布这个日历应用。
他们把所有的基础设施留在控件里，并花上两天在上面堆砌一个糟糕的日历。
他们甚至会认为，下一版还要这么做。

一旦他们开始反思如何具体实现他们的抽象设计，
就会意识到设计彻头彻尾地错了。
现在，他们无路可走，只好从头再来。
对此，我已经见怪不怪了。
我坚信最小主义(minimalist)的原则。
除非你真的是要解决通用的问题，不要为解决一个特例而推出一个框架，
因为你不知道那个框架会是什么样。

Bruce Eckel: 极限编程认为，“做可以运行的最简单的事情”。

Anders Hejlsberg: 是呀，爱因斯坦曰：“尽可能最简单，而不是更简单。”
我顾虑的是，受检异常是程序员的镣铐。
你会看到程序员使用着包裹了重重throw语句的新API，
然后你会发现到他们的代码多么地复杂，
并且意识到受检异常根本帮不上什么。
问题在于专断的API设计者要求你怎样去处理异常。他们本不应该这么干的。

---

###版本(versionability)

Bill Venners: 你提到了受检异常带来的拓展性(scalability)和版本(versioning)上的顾虑。
你可以解释一下提到的这两点吗？

Anders Hejlsberg: 从版本开始吧，因为这一点相当显而易见。
假设我写了个抛出异常A，B，C的方法*foo*。
在*foo*的第二版，我加入了新的特性，现在*foo*抛出了异常D。
由于当前的调用者几乎不会去处理异常D，我不可能声明抛出异常D。

在新的版本里加入新的异常声明将会破坏客户代码。
好比在接口中加入新的方法。
在你发布(publish)一个接口后，实际上它是不可变的，因为一旦加入新的方法，所有的实现都会受株连。
你不得不创建一个新的接口。
同样地，应对新的异常D，要不创建新的方法*foo2*，要不在*foo*里面捕获异常D，并将D转换成A/B/C。

Bill Venners: 但是即使在没有受检异常的语言里，你不也可能因此破坏客户代码？
如果新的*foo*将抛出新的交由客户去处理的异常，他们的代码不也会由于缺乏对新异常的预见，而遭受破坏吗？

Anders Hejlsberg: 不，因为在大多数情况下，人们不在乎。
他们不会处理这样的异常。
在信息循环中，会有底层的异常处理器。
异常处理器会诊断出哪里出错并保持运行。
程序员到处写下try...finally来保护代码，一旦异常发生，他们可以回到出错的地方，但他们并不对处理异常感兴趣。

throws语句，至少在Java的实现中，不是必须强迫你处理异常，但若不去处理，它将强迫你注意到有异常抛出了。
它要求你要不捕获异常，要不把异常加入到你自己的throws语句中。
为了满足这个要求，人们不得不做些可笑的事。
比如，他们用“throws Exception”来修饰每一个方法。
这仅仅让受检异常的美好预期落了个空，还让程序员写出僵化的代码(gobbledy gunk)。
这一点都帮不上什么忙。

Bill Venners: 所以你认为更普遍的做法是调用者将异常交由调用栈上的通用catch语句处理，而不需要显式处理它？

Anders Hejlsberg: 人们总肤浅地认为，异常是为被处理而生的。
在我看来，事实上，在一个良好的应用中，十次有一次是由try...finally来完成try...catch做的事。
或者在C#中，使用类似于try...finally的语句。

Bill Venners: finally里的是什么？

Anders Hejlsberg: 在finally里，你不需要处理异常就能保护你的代码。
你只需要在一些地方处理错误。
显然在一些事件驱动型应用，你一般只在主要的信息冒泡出放置异常处理，来对付那些发生的异常。
当然你需要彻底地回收(deallocating)所有的获得的资源，等等。
你在最后才打扫战场，所以你总保持一个确定的状态。
你不会想要一个在100个不同的地方处理异常，冒出一个错误报告框的程序。
假如你想改变产生对话框的方式呢？
那将会很糟糕。
异常处理应该凝练，并且一旦异常产生，你应该优先保护好自己的代码。

---

###拓展性(scalability)

Bill Venners: 受检异常在拓展性上的问题呢？

Anders Hejlsberg: 这个问题一定程度上跟版本上的问题有关。
即使是在小范例中，你也会看到你需要捕获一个FileNotFoundException，这是不是过头了？
嗯，这仅仅是想要调用一个API的结果。
当你开始建造一个与四五个不同的子系统交互的大型系统，问题越发严重。
每个子系统会抛出四到十个异常。
现在，每一次当你在梯状的架构中蹒跚时，埋在脚下的是指数增加的需要处理的异常。
最后，你不得不以抛出四十个异常的声明告终。
然而，一旦你把它加入另一个子系统，你可能需要的是八十个异常抛出声明。
就像失去控制的气球，异常们一跃而出。

从大的方面说，受检异常如此恼人以至于人们开始敷衍对待。
他们不是每次都用"throws Exception"，就是——我都不能想清楚有多少次了——用毛茸茸的try...catch包裹起来。
他们想，“我终究会回来的解决这些空catch语句的”，然后就没有然后了。
这种情况下，受检异常实际上损害了系统的质量。

当你谈到所有这些问题时，对我来说，为C#加入受检异常机制需要更慎重的考虑。
也就是说，了解什么异常可以抛出，并且有一系列方法来检查是至关重要的。
我不认为我们可以构造严格的而且快的准则来发现一个编译错误。
但我认为我们可以尽力改善分析工具来发现可疑代码，包括未捕获的异常，并且向你指出潜在的漏洞。

**END**

[原文在此](http://www.artima.com/intv/handcuffs.html)
