本文是《[Understanding GIL](http://www.dabeaz.com/python/UnderstandingGIL.pdf)》的读后感。

什么是GIL呢？就是全局解释器锁。Python作为一种解释型的语言，代码需要在运行时由Python解释器进行实时解释。所以每当Python代码要想运行，需要有一个解释器实例来处理代码，比诸如C，Java之类的编译型语言多了个中间层。

这么做有一个缺陷，就是在多线程的情况下，多个线程共享同一个解释器实例，每次都只有一个线程可以被解释器所支持。于是，如果这些线程都是CPU-bound（计算密集型）的线程，那么就会产生锁争用的情况。每个线程都缺乏IO阻塞，像个吝啬鬼一样牢牢抓住自己那份解释器份额绝不分给同伴。这么一来，多线程的优势就被限制住了。所以GIL一直是Python心中永远的痛。

GIL的释放需要以上两个条件之一：

1.  该线程在执行完一段（包括若干个tick）代码之后
2.  该线程进行IO操作

GIL的实现是一个semaphore，包括一个mutex和cond。

获取锁时，获取mutex，如果没法得到锁，cond_wait，最后释放mutex。释放锁时，先获取mutex进行锁记录的修改，再释放mutex，然后发送cond_signal给之前因为获取不了锁而cond_wait的线程。

GIL释放后，所有的线程都可以重新获取，就像抛球一样。不过有些线程就是长得高……所有的线程按优先级排队，OS会把GIL分配给优先级高的线程。

Python 3.2后引入了新的GIL。添加一个全局变量用于线程间的协调。当某个线程等到黄花菜都凉了的时候，它会设置这个变量为1。当前线程会因此不得不忍痛让出GIL。

当然这个“让出”不是直接丢掉GIL那么简单。当前线程会发送一个信号，然后停下来，等待某个线程的ACK。在接到ACK之后，当前线程才会真正suspend起来。这么一来，锁争用就得到了避免。

但是这么做有一个严重的问题……作者在文中就举了个例子。如果有一个线程是CPU-bound线程，另一个线程则需要通过I/O转发一批数据，那么在新的GIL设计下，CPU-bound线程需要等到I/O线程等得心急如焚，设置了协调的全局变量时才会让出GIL。而假如这个I/O线程进行的不是阻塞I/O操作，那么每次I/O之后，GIL又会回到CPU-bound的线程手上，然后自己还要再等上很长一段时间 - 这样继续重复 - 重复……

作者提出可能的解决方法是分别对待CPU-bound线程和I/O-bound线程，并且动态调整优先级。

>  注： 虽然这里讲的是python的GIL，但其实Ruby也有GIL的问题。Ruby开发者也一直准备淘汰掉GIL，使用Actor或其他的并发模型。作为一个Ruby粉，希望我大Ruby早日脱离GIL的苦海，争取向现代语言靠齐。
