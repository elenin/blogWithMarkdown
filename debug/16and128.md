为什么我的程序处理不了>=16的情况？
=====

在昨天写我的obj-c小练习*powerby2*的时候，我发现有一个蹊跷的地方。
就是当一个NSNumber的值达到16或以上时，就会导致某个流程无法进行

排查过程没有什么好说的，就是二分法排错。最后也锁定了错误所在。

程序有一处逻辑判断，需要判断两个NSNumber是不是相等。
我的写法是
`self.value[step + j] == self.value[step + k]`

如果你用过obj-c，或者java，你可能会对此皱眉头。
虽然这种设计比较反人类，但是在这两种语言中，`==`操作符只能比较两个类的内存地址是否相同，如果你想要比较两个类是否相同，需要调用专门的方法。
在java中，这个方法来自`Object`的`compareTo`，通过返回一个整数来判断是否大于、等于或小于。
在obj-c中，这个方法来自`NSObject`的`compare`，通过返回`NSOrderSame`和`NSOrderAscend`、`NSOrderDescend`来分别表示等于、大于、小于。
（看到了吗，obj-c又一次表现出了对封装和一致性的追求。）
一般这两个根类的子类都会重载这两个方法。

说了这么多，你应该已经明白，如果需要比较，应该使用`compare`而非`==`。否则，就只能使用`raw type`，比如使用`NSInteger`代替`NSNumber`。
要养成这种习惯很困难，就像刚开始编程时要用`==`来代替表示判断相等的`=`。
当然这种转变并不像刚开始那么困难，至少我已经适应了Shell里面的`=`和` = `之间的差别了:-D

如果本文就停止在这里，那么就只是一篇简单的经验文。不过我还是想升华一下主题，^_^

未定义行为
-----

前面讲到，当NSNumber的值达到16或以上时，就会出问题。
而这个问题，出在 `self.value[step + j] == self.value[step + k]`身上。
如果原因是`==`和`compare`的原因，那么为什么要等到>=16才会被触发？

debug一下，你就知道。原来不大于8的NSNumber的内存位置都是一样的。
也即是说，程序已经分配好若干个NSNumber，而调用时只是引用它们而已。
既然同等的值的NSNumber都是对一个NSNumber的引用，那么`==`显然会返回正确的结果。

所以，`==`触发的，是一个**未定义行为**！

如果触发了**未定义行为**，那么一切皆有可能。也许程序因为NSNumber的值不大于8就可以正确运行，但是情况一变，就会导致各种杯具。

在java里也有同样的现象。Integer在正负128内的值都是被缓存的，也即是说，在这个范围里，`==`也能正确运行。
只不过你会埋下一颗定时炸弹罢了。

总结
-----

**珍爱生命，远离未定义行为！**
