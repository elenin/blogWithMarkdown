在C语言里，一个数是什么类型的？
====

之前我一直在做一个测试计算LU分解的最佳方法的实验。但是有一个诡异的错误，总在算到30000行矩阵时出现，程序会停留在那里并一直卡着不动，有时又会产生segment fault。

由于这个3万行矩阵问题，我大胆探索、小心求证的道路被隔断了。
我把这个问题命名为“3万矩阵陷阱”。虽然我苦思冥想多日，但是依然不得其解。
这个问题一直缠绕在我的心头。

一天晚上，我躺在床上时，突然意识到30000行float类型矩阵，其大小已经超过int类型可以表示的范围！会不会是malloc的参数问题？

果然，我检查了malloc的参数，虽然malloc的形参是size_t类型(在64bit系统上是64bit大小)，但是我传入的是int，显然不会帮我提升类型。
也就是说，malloc现在接受的是一个由于溢出而产生的负数。

那么，malloc会对负数做什么处理呢？于是我写了个test.c

    #include<stdio.h>
    #include<stdlib.h>
    int main()
    {
        int overflow = 30000 * 30000 * 4;
        int *c = (int*)malloc(overflow);
        printf("%x\n",c);
    }

答案是很坑爹的：有警告(当然是因为计算溢出而出现警告，不是因为malloc的参数问题而出现警告)，
无编译错误(shit!)，
而且malloc还很安静地执行了，不抛出任何异常(当然没有)或者segment fault.
不过执行结果很蛋疼：c是一个空指针。
空指针是C/C++中邪恶的精灵，因为它带来的后果是不可预期的。
而且当bug出现时，你会找错病因所在。
这就解释了为什么3万矩阵问题会如此古怪。
看来这又是C语言的又一个设计缺陷。难怪有经验的程序员会检测每一次内存分配后指针的值。

为什么起一个这样的题目？
----

现在你应该会感到奇怪，既然是malloc的问题，为什么题目会提到C语言中数字的类型呢？

*在发现malloc的问题，我又想起已经曾感到好奇的事：在C语言中，字面量数字是什么类型的？*

为了查证这个问题，我又写了个t2.c:

    printf("%d\n",30000 * 30000 * 4);

猜猜我得到什么？一个负数。

这能说明什么问题么？不能，因为我用了%d，这个标记只能够输出int类型。
C/C++中古怪的类型自动转换偷偷的帮我把字面量类型转换成int类型。
不信你可以试试这个：

    printf("%d\n",(unsigned int)(30000 * 30000 * 4));

那么说printf函数是用不了的。
sizeof呢？也不行，sizeof返回一个unsigned long。而且无论是unsigned int 或者int都是4个字节。
顺便说一下，unsigned long 和 long都是8个字节。而且在64bit的系统中，long long和long都是8位的，没想到吧！

最后我想到了办法，用if判断语句。

    int n = 1024 * 1024 * 1024;
    if(1024 * 1024 * 1024 * 2 < n)
    {
        printf("You are right!");
    }

输出结果是“You are right!”。

Oh,yeah！当然你也许会质疑，不过是自动类型转换的又一个恶作剧罢了。
那么看看这个：

    unsigned int n = 1024 * 1024 * 1024;
    if(1024 * 1024 * 1024 * 2 < n)
    {
        printf("You are right!");
    }

输出结果是“You are right!”。

这下你可质疑不了了吧！

显然，在C语言中，数字字面量的类型是int类型，不过由于自动类型转换的存在，使得这一事实相对模糊。

于是乎有了下面的结果：

    if(1024 * 1024 * 1024 * 2 < 0)
    {
        printf("You are right!");
    }

Of course, I am right again!
